// Generated by gencpp from file niryo_robot_status/RobotStatus.msg
// DO NOT EDIT!


#ifndef NIRYO_ROBOT_STATUS_MESSAGE_ROBOTSTATUS_H
#define NIRYO_ROBOT_STATUS_MESSAGE_ROBOTSTATUS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace niryo_robot_status
{
template <class ContainerAllocator>
struct RobotStatus_
{
  typedef RobotStatus_<ContainerAllocator> Type;

  RobotStatus_()
    : robot_status(0)
    , robot_status_str()
    , robot_message()
    , logs_status(0)
    , logs_status_str()
    , logs_message()
    , out_of_bounds(false)
    , rpi_overheating(false)  {
    }
  RobotStatus_(const ContainerAllocator& _alloc)
    : robot_status(0)
    , robot_status_str(_alloc)
    , robot_message(_alloc)
    , logs_status(0)
    , logs_status_str(_alloc)
    , logs_message(_alloc)
    , out_of_bounds(false)
    , rpi_overheating(false)  {
  (void)_alloc;
    }



   typedef int8_t _robot_status_type;
  _robot_status_type robot_status;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _robot_status_str_type;
  _robot_status_str_type robot_status_str;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _robot_message_type;
  _robot_message_type robot_message;

   typedef int8_t _logs_status_type;
  _logs_status_type logs_status;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _logs_status_str_type;
  _logs_status_str_type logs_status_str;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _logs_message_type;
  _logs_message_type logs_message;

   typedef uint8_t _out_of_bounds_type;
  _out_of_bounds_type out_of_bounds;

   typedef uint8_t _rpi_overheating_type;
  _rpi_overheating_type rpi_overheating;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(UPDATE)
  #undef UPDATE
#endif
#if defined(_WIN32) && defined(REBOOT)
  #undef REBOOT
#endif
#if defined(_WIN32) && defined(SHUTDOWN)
  #undef SHUTDOWN
#endif
#if defined(_WIN32) && defined(FATAL_ERROR)
  #undef FATAL_ERROR
#endif
#if defined(_WIN32) && defined(MOTOR_ERROR)
  #undef MOTOR_ERROR
#endif
#if defined(_WIN32) && defined(COLLISION)
  #undef COLLISION
#endif
#if defined(_WIN32) && defined(USER_PROGRAM_ERROR)
  #undef USER_PROGRAM_ERROR
#endif
#if defined(_WIN32) && defined(UNKNOWN)
  #undef UNKNOWN
#endif
#if defined(_WIN32) && defined(BOOTING)
  #undef BOOTING
#endif
#if defined(_WIN32) && defined(REBOOT_MOTOR)
  #undef REBOOT_MOTOR
#endif
#if defined(_WIN32) && defined(CALIBRATION_NEEDED)
  #undef CALIBRATION_NEEDED
#endif
#if defined(_WIN32) && defined(CALIBRATION_IN_PROGRESS)
  #undef CALIBRATION_IN_PROGRESS
#endif
#if defined(_WIN32) && defined(LEARNING_MODE)
  #undef LEARNING_MODE
#endif
#if defined(_WIN32) && defined(STANDBY)
  #undef STANDBY
#endif
#if defined(_WIN32) && defined(MOVING)
  #undef MOVING
#endif
#if defined(_WIN32) && defined(RUNNING_AUTONOMOUS)
  #undef RUNNING_AUTONOMOUS
#endif
#if defined(_WIN32) && defined(RUNNING_DEBUG)
  #undef RUNNING_DEBUG
#endif
#if defined(_WIN32) && defined(PAUSE)
  #undef PAUSE
#endif
#if defined(_WIN32) && defined(LEARNING_MODE_AUTONOMOUS)
  #undef LEARNING_MODE_AUTONOMOUS
#endif
#if defined(_WIN32) && defined(LEARNING_TRAJECTORY)
  #undef LEARNING_TRAJECTORY
#endif
#if defined(_WIN32) && defined(REBOOT_MOTOR)
  #undef REBOOT_MOTOR
#endif
#if defined(_WIN32) && defined(FATAL)
  #undef FATAL
#endif
#if defined(_WIN32) && defined(ERROR)
  #undef ERROR
#endif
#if defined(_WIN32) && defined(WARN)
  #undef WARN
#endif
#if defined(_WIN32) && defined(NONE)
  #undef NONE
#endif

  enum {
    UPDATE = -7,
    REBOOT = -6,
    SHUTDOWN = -5,
    FATAL_ERROR = -4,
    MOTOR_ERROR = -3,
    COLLISION = -2,
    USER_PROGRAM_ERROR = -1,
    UNKNOWN = 0,
    BOOTING = 1,
    REBOOT_MOTOR = 2,
    CALIBRATION_NEEDED = 3,
    CALIBRATION_IN_PROGRESS = 4,
    LEARNING_MODE = 5,
    STANDBY = 6,
    MOVING = 7,
    RUNNING_AUTONOMOUS = 8,
    RUNNING_DEBUG = 9,
    PAUSE = 10,
    LEARNING_MODE_AUTONOMOUS = 11,
    LEARNING_TRAJECTORY = 12,
    REBOOT_MOTOR = 13,
    FATAL = -3,
    ERROR = -2,
    WARN = -1,
    NONE = 0,
  };


  typedef boost::shared_ptr< ::niryo_robot_status::RobotStatus_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::niryo_robot_status::RobotStatus_<ContainerAllocator> const> ConstPtr;

}; // struct RobotStatus_

typedef ::niryo_robot_status::RobotStatus_<std::allocator<void> > RobotStatus;

typedef boost::shared_ptr< ::niryo_robot_status::RobotStatus > RobotStatusPtr;
typedef boost::shared_ptr< ::niryo_robot_status::RobotStatus const> RobotStatusConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::niryo_robot_status::RobotStatus_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::niryo_robot_status::RobotStatus_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::niryo_robot_status::RobotStatus_<ContainerAllocator1> & lhs, const ::niryo_robot_status::RobotStatus_<ContainerAllocator2> & rhs)
{
  return lhs.robot_status == rhs.robot_status &&
    lhs.robot_status_str == rhs.robot_status_str &&
    lhs.robot_message == rhs.robot_message &&
    lhs.logs_status == rhs.logs_status &&
    lhs.logs_status_str == rhs.logs_status_str &&
    lhs.logs_message == rhs.logs_message &&
    lhs.out_of_bounds == rhs.out_of_bounds &&
    lhs.rpi_overheating == rhs.rpi_overheating;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::niryo_robot_status::RobotStatus_<ContainerAllocator1> & lhs, const ::niryo_robot_status::RobotStatus_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace niryo_robot_status

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::niryo_robot_status::RobotStatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::niryo_robot_status::RobotStatus_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::niryo_robot_status::RobotStatus_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::niryo_robot_status::RobotStatus_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::niryo_robot_status::RobotStatus_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::niryo_robot_status::RobotStatus_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::niryo_robot_status::RobotStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "348f86f9a8f05f5136ecc49809ffebf2";
  }

  static const char* value(const ::niryo_robot_status::RobotStatus_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x348f86f9a8f05f51ULL;
  static const uint64_t static_value2 = 0x36ecc49809ffebf2ULL;
};

template<class ContainerAllocator>
struct DataType< ::niryo_robot_status::RobotStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "niryo_robot_status/RobotStatus";
  }

  static const char* value(const ::niryo_robot_status::RobotStatus_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::niryo_robot_status::RobotStatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int8 UPDATE=-7\n"
"int8 REBOOT=-6\n"
"int8 SHUTDOWN=-5\n"
"int8 FATAL_ERROR=-4     # Node crash\n"
"int8 MOTOR_ERROR=-3     # Electrical/overload or disconnected motor error\n"
"int8 COLLISION=-2\n"
"int8 USER_PROGRAM_ERROR=-1\n"
"int8 UNKNOWN=0\n"
"int8 BOOTING=1          # Robot is booting\n"
"int8 REBOOT_MOTOR=2\n"
"int8 CALIBRATION_NEEDED=3\n"
"int8 CALIBRATION_IN_PROGRESS=4\n"
"int8 LEARNING_MODE=5\n"
"int8 STANDBY=6          # Torque ON\n"
"int8 MOVING=7           # Moving with NiryoStudio interface or ros topics without user program\n"
"int8 RUNNING_AUTONOMOUS=8   # User program is running\n"
"int8 RUNNING_DEBUG=9    # Debug program is running\n"
"int8 PAUSE=10           # User program paused\n"
"int8 LEARNING_MODE_AUTONOMOUS=11    # User program is running + Learning mode activated\n"
"int8 LEARNING_TRAJECTORY = 12\n"
"int8 REBOOT_MOTOR=13\n"
"\n"
"int8 robot_status\n"
"string robot_status_str\n"
"string robot_message\n"
"\n"
"int8 FATAL=-3\n"
"int8 ERROR=-2\n"
"int8 WARN=-1\n"
"int8 NONE=0\n"
"\n"
"int8 logs_status\n"
"string logs_status_str\n"
"string logs_message\n"
"\n"
"bool out_of_bounds\n"
"bool rpi_overheating\n"
;
  }

  static const char* value(const ::niryo_robot_status::RobotStatus_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::niryo_robot_status::RobotStatus_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.robot_status);
      stream.next(m.robot_status_str);
      stream.next(m.robot_message);
      stream.next(m.logs_status);
      stream.next(m.logs_status_str);
      stream.next(m.logs_message);
      stream.next(m.out_of_bounds);
      stream.next(m.rpi_overheating);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RobotStatus_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::niryo_robot_status::RobotStatus_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::niryo_robot_status::RobotStatus_<ContainerAllocator>& v)
  {
    s << indent << "robot_status: ";
    Printer<int8_t>::stream(s, indent + "  ", v.robot_status);
    s << indent << "robot_status_str: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.robot_status_str);
    s << indent << "robot_message: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.robot_message);
    s << indent << "logs_status: ";
    Printer<int8_t>::stream(s, indent + "  ", v.logs_status);
    s << indent << "logs_status_str: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.logs_status_str);
    s << indent << "logs_message: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.logs_message);
    s << indent << "out_of_bounds: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.out_of_bounds);
    s << indent << "rpi_overheating: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rpi_overheating);
  }
};

} // namespace message_operations
} // namespace ros

#endif // NIRYO_ROBOT_STATUS_MESSAGE_ROBOTSTATUS_H
